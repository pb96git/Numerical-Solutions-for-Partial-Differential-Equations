""" 
Exact Riemann Solver for the Time-Dependent 
    One-Dimensional Euler Equations 

Purpose: To solve the Riemann problem exactly
         for the time-dependent one-dimensional 
         Euler equations for an ideal gas.

Theory is found in Ref. 1, Chapter 4 and in original 
references therein.

Reference:
1. Toro, E. F., "Riemann Solvers and Numerical 
                Methods for Fluid Dynamics" 
                Springer-Verlag, 1997
                Second Edition, 1999

This program logic is part of:

NUMERICA
A Library of Source Codes for Teaching, 
Research and Applications, 
by E. F. Toro
Published by NUMERITEK LTD, 1999
Website: www.numeritek.com
 """

import math
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter
import numpy as np
import os

#--------------------------------------------------------------#
#             Initalization and variable precomputing
#--------------------------------------------------------------#

class Gammas:
    def __init__(self):
        self.GAMMA = None
        self.G1 = None
        self.G2 = None
        self.G3 = None
        self.G4 = None
        self.G5 = None
        self.G6 = None
        self.G7 = None
        self.G8 = None

class States:
    def __init__(self):
        self.DL = None  # Density (left state)
        self.UL = None  # Velocity (left state)
        self.PL = None  # Pressure (left state)
        self.CL = None  # Sound speed (left state)
        self.DR = None  # Density (right state)
        self.UR = None  # Velocity (right state)
        self.PR = None  # Pressure (right state)
        self.CR = None  # Sound speed (right state)

# Initialize global variables
gammas = Gammas()
states = States()

def read_input(file_name):
    """
    Reads input data from the input file 'TestX_input.txt' and handles comments.
    """
    def clean_line(line):
        # Split the line at '!' or '#' and strip extra spaces
        return line.split('!')[0].split('#')[0].strip()

    with open(file_name, 'r') as file:
        lines = file.readlines()
        
        # Clean each line to remove comments and extra spaces
        clean_lines = [clean_line(line) for line in lines if clean_line(line)]

        # Parse the cleaned lines
        domlen = float(clean_lines[0])   # Domain length
        diaph = float(clean_lines[1])    # Initial discontinuity position
        cells = int(clean_lines[2])      # Number of computing cells
        gammas.GAMMA = float(clean_lines[3])  # Ratio of specific heats
        timeout = float(clean_lines[4])  # Output time
        states.DL = float(clean_lines[5])  # Density left
        states.UL = float(clean_lines[6])  # Velocity left
        states.PL = float(clean_lines[7])  # Pressure left
        states.DR = float(clean_lines[8])  # Density right
        states.UR = float(clean_lines[9])  # Velocity right
        states.PR = float(clean_lines[10]) # Pressure right
        mpa = float(clean_lines[11])  # Normalizing constant

    return domlen, diaph, cells, timeout, mpa

def compute_gamma_constants():
    """Computes gamma-related constants."""
    GAMMA = gammas.GAMMA
    gammas.G1 = (GAMMA - 1.0) / (2.0 * GAMMA)
    gammas.G2 = (GAMMA + 1.0) / (2.0 * GAMMA)
    gammas.G3 = 2.0 * GAMMA / (GAMMA - 1.0)
    gammas.G4 = 2.0 / (GAMMA - 1.0)
    gammas.G5 = 2.0 / (GAMMA + 1.0)
    gammas.G6 = (GAMMA - 1.0) / (GAMMA + 1.0)
    gammas.G7 = (GAMMA - 1.0) / 2.0
    gammas.G8 = GAMMA - 1.0

def compute_sound_speeds():
    """Computes sound speeds for left and right states."""
    states.CL = math.sqrt(gammas.GAMMA * states.PL / states.DL)
    states.CR = math.sqrt(gammas.GAMMA * states.PR / states.DR)

def check_vacuum_condition():
    """Checks the pressure positivity condition."""
    if gammas.G4 * (states.CL + states.CR) <= (states.UR - states.UL):
        print("\n*** Vacuum is generated by data ***")
        print("*** Program stopped ***\n")
        exit(1)

#--------------------------------------------------------------#
#                          Core functions
#--------------------------------------------------------------#

def GUESSP():
    """
     Purpose: to provide a guessed value for pressure
              PM in the Star Region. The choice is made
              according to adaptive Riemann solver using
              the PVRS, TRRS and TSRS approximate
              Riemann solvers. See Sect. 9.5 of Chapt. 9
              of Ref. 1
    """
    QUSER = 2.0  # Threshold for solver selection

    # Compute guess pressure using PVRS (Pressure-Velocity Riemann Solver)
    CUP = 0.25 * (states.DL + states.DR) * (states.CL + states.CR)
    PPV = 0.5 * (states.PL + states.PR) + 0.5 * (states.UL - states.UR) * CUP
    PPV = max(0.0, PPV)  # Ensure pressure is non-negative
    PMIN = min(states.PL, states.PR)
    PMAX = max(states.PL, states.PR)
    QMAX = PMAX / PMIN

    # Select solver
    if QMAX <= QUSER and (PMIN <= PPV <= PMAX):
        # PVRS solver
        PM = PPV
    elif PPV < PMIN:
        # Two-Rarefaction Riemann solver (TRRS)
        PQ = (states.PL / states.PR) ** gammas.G1
        UM = (PQ * states.UL / states.CL + states.UR / states.CR + 
              gammas.G4 * (PQ - 1.0)) / (PQ / states.CL + 1.0 / states.CR)
        PTL = 1.0 + gammas.G7 * (states.UL - UM) / states.CL
        PTR = 1.0 + gammas.G7 * (UM - states.UR) / states.CR
        PM = 0.5 * (states.PL * PTL ** gammas.G3 + states.PR * PTR ** gammas.G3)
    else:
        # Two-Shock Riemann solver (TSRS) with PVRS estimate
        GEL = math.sqrt((gammas.G5 / states.DL) / (gammas.G6 * states.PL + PPV))
        GER = math.sqrt((gammas.G5 / states.DR) / (gammas.G6 * states.PR + PPV))
        PM = (GEL * states.PL + GER * states.PR - (states.UR - states.UL)) / (GEL + GER)
    
    return PM

def PREFUN(P, DK, PK, CK):
    """
    Evaluates the pressure function (F) and its derivative (FD) in exact Riemann solver.
    Inputs:
        P  - Pressure
        DK - Density
        PK - Initial Pressure
        CK - Sound speed
    Outputs:
        F  - Pressure function
        FD - Derivative of the pressure function
    """
    if P <= PK:
        # Rarefaction wave
        PRAT = P / PK
        F = gammas.G4 * CK * (PRAT ** gammas.G1 - 1.0)
        FD = (1.0 / (DK * CK)) * PRAT ** (-gammas.G2)
    else:
        # Shock wave
        AK = gammas.G5 / DK
        BK = gammas.G6 * PK
        QRT = math.sqrt(AK / (BK + P))
        F = (P - PK) * QRT
        FD = (1.0 - 0.5 * (P - PK) / (BK + P)) * QRT
    
    return F, FD


def STARPU(PSTART):
    """
    Computes the pressure p*, velocity u*, and densities in the star region using Newton-Raphson iteration.
    Returns: p*, u*, rho*_L, rho*_R.
    """
    TOLPRE = 1.0e-6  # Convergence tolerance
    NRITER = 20      # Max iterations

    # Initial guess
    POLD = PSTART
    UDIFF = states.UR - states.UL

    for _ in range(NRITER):
        # Compute pressure functions for left and right
        FL, FLD = PREFUN(POLD, states.DL, states.PL, states.CL)
        FR, FRD = PREFUN(POLD, states.DR, states.PR, states.CR)

        # Newton-Raphson iteration
        PNEW = POLD - (FL + FR + UDIFF) / (FLD + FRD)
        CHANGE = 2.0 * abs((PNEW - POLD) / (PNEW + POLD))

        if CHANGE <= TOLPRE:
            break
        POLD = max(PNEW, TOLPRE)  # Ensure positive pressure

    else:
        raise ValueError("Newton-Raphson failed to converge for p*")

    # Final p*
    p_star = PNEW

    # Compute velocity u* in the star region
    FL, _ = PREFUN(p_star, states.DL, states.PL, states.CL)
    FR, _ = PREFUN(p_star, states.DR, states.PR, states.CR)
    u_star = 0.5 * (states.UL + states.UR + FR - FL)

    # Compute star region densities
    if p_star <= states.PL:
        # Left rarefaction
        rho_star_L = states.DL * (p_star / states.PL) ** (1.0 / gammas.GAMMA)
    else:
        # Left shock
        rho_star_L = states.DL * (p_star / states.PL + gammas.G6) / (p_star / states.PL * gammas.G6 + 1.0)

    if p_star <= states.PR:
        # Right rarefaction
        rho_star_R = states.DR * (p_star / states.PR) ** (1.0 / gammas.GAMMA)
    else:
        # Right shock
        rho_star_R = states.DR * (p_star / states.PR + gammas.G6) / (p_star / states.PR * gammas.G6 + 1.0)

    return p_star, u_star, rho_star_L, rho_star_R


def SAMPLE(PM, UM, S):
    """
    Samples the solution throughout the wave pattern.
    Input:
        PM - Pressure in star region
        UM - Velocity in star region
        S  - Speed X/T
    Output:
        D  - Density at the sampled point
        U  - Velocity at the sampled point
        P  - Pressure at the sampled point
    """
    # Local variables
    D, U, P = 0.0, 0.0, 0.0

    # Left of the contact discontinuity
    if S <= UM:
        if PM <= states.PL:
            # Left rarefaction
            SHL = states.UL - states.CL
            if S <= SHL:
                # Left data state
                D, U, P = states.DL, states.UL, states.PL
            else:
                CML = states.CL * (PM / states.PL) ** gammas.G1
                STL = UM - CML
                if S > STL:
                    # Star Left state
                    D = states.DL * (PM / states.PL) ** (1.0 / gammas.GAMMA)
                    U = UM
                    P = PM
                else:
                    # Inside left fan
                    U = gammas.G5 * (states.CL + gammas.G7 * states.UL + S)
                    C = gammas.G5 * (states.CL + gammas.G7 * (states.UL - S))
                    D = states.DL * (C / states.CL) ** gammas.G4
                    P = states.PL * (C / states.CL) ** gammas.G3
        else:
            # Left shock
            PML = PM / states.PL
            SL = states.UL - states.CL * math.sqrt(gammas.G2 * PML + gammas.G1)
            if S <= SL:
                # Left data state
                D, U, P = states.DL, states.UL, states.PL
            else:
                # Star Left state
                D = states.DL * (PML + gammas.G6) / (PML * gammas.G6 + 1.0)
                U = UM
                P = PM
    else:
        # Right of the contact discontinuity
        if PM > states.PR:
            # Right shock
            PMR = PM / states.PR
            SR = states.UR + states.CR * math.sqrt(gammas.G2 * PMR + gammas.G1)
            if S >= SR:
                # Right data state
                D, U, P = states.DR, states.UR, states.PR
            else:
                # Star Right state
                D = states.DR * (PMR + gammas.G6) / (PMR * gammas.G6 + 1.0)
                U = UM
                P = PM
        else:
            # Right rarefaction
            SHR = states.UR + states.CR
            if S >= SHR:
                # Right data state
                D, U, P = states.DR, states.UR, states.PR
            else:
                CMR = states.CR * (PM / states.PR) ** gammas.G1
                STR = UM + CMR
                if S <= STR:
                    # Star Right state
                    D = states.DR * (PM / states.PR) ** (1.0 / gammas.GAMMA)
                    U = UM
                    P = PM
                else:
                    # Inside right fan
                    U = gammas.G5 * (-states.CR + gammas.G7 * states.UR + S)
                    C = gammas.G5 * (states.CR - gammas.G7 * (states.UR - S))
                    D = states.DR * (C / states.CR) ** gammas.G4
                    P = states.PR * (C / states.CR) ** gammas.G3
    
    return D, U, P

#--------------------------------------------------------------#
#                          Calculation
#--------------------------------------------------------------#

def solve_Riemann_problem(domlen, timeout, cells):
    """Solve the Riemann problem."""
    # Compute sound speeds
    compute_sound_speeds()
    
    # Solve for PM and UM
    PM = GUESSP()

    # Solve for star region values
    PM, UM, rho_star_L, rho_star_R = STARPU(PM)

    # Discretize the spatial domain
    dx = domlen / cells
    positions = [(i + 0.5) * dx for i in range(cells)]
    
    # Sample the solution
    density = []
    velocity = []
    pressure = []
    internal_energy = []
    
    for xpos in positions:
        s = (xpos - domlen / 2.0) / timeout
        D, U, P = SAMPLE(PM, UM, s)
        density.append(D)
        velocity.append(U)
        pressure.append(P)
        e = P / ((gammas.GAMMA - 1.0) * D)  # Compute internal energy
        internal_energy.append(e)
    
    return positions, density, velocity, pressure, internal_energy

#--------------------------------------------------------------#
#                        Post-process
#--------------------------------------------------------------#
def plot_Riemann_problem(positions, density, velocity, pressure, internal_energy, 
                         save=False, filename="TestX_solution.png", 
                         initial_values=None, computed_values=None, star_values=None
                         ):
    """
    Plot the density, velocity, pressure, and internal energy profiles in a 2x2 layout.
    Display initial values, computed pressures, and star region values on the plot.
    Adds gray vertical lines across all subplots if specified.

    Parameters:
        positions (list): List of spatial positions.
        density (list): Density values at each position.
        velocity (list): Velocity values at each position.
        pressure (list): Pressure values at each position.
        internal_energy (list): Internal energy values at each position.
        save (bool): If True, saves the plot to a file.
        filename (str): Name of the output file to save the plot.
        initial_values (tuple): (ρL, uL, pL, ρR, uR, pR) for initial states.
        computed_values (tuple): (p*, p_TR, p_PV, p_TS, 0.5*(pL + pR)) for computed pressures.
        star_values (tuple): (p*, u*, ρ*_L, ρ*_R) for the star region.
    """
    # Create the Results folder if it doesn't exist
    results_folder = os.path.join(os.getcwd(), "Results")
    if save:
        if not os.path.exists(results_folder):
            os.makedirs(results_folder)
    
    # Full path to save the file
    save_path = os.path.join(results_folder, filename)

    # Plot the results
    fig, axes = plt.subplots(2, 2, figsize=(12, 8))  # 2 rows, 2 columns

    # Density profile (Top-left)
    axes[0, 0].plot(positions, density, label='Density')
    
    axes[0, 0].set_ylabel('Density')
    axes[0, 0].set_title('Density')
    axes[0, 0].grid()
    axes[0, 0].legend()

    # Velocity profile (Top-right)
    axes[0, 1].plot(positions, velocity, label='Velocity', color='orange')
    axes[0, 1].set_ylabel('Velocity')
    axes[0, 1].set_title('Velocity')
    axes[0, 1].grid()
    axes[0, 1].legend()

    # Pressure profile (Bottom-left)
    axes[1, 0].plot(positions, pressure, label='Pressure', color='red')
    axes[1, 0].set_ylabel('Pressure')
    axes[1, 0].set_title('Pressure')
    axes[1, 0].set_xlabel('Position')
    axes[1, 0].grid()
    axes[1, 0].legend()

    # Internal energy profile (Bottom-right)
    axes[1, 1].plot(positions, internal_energy, label='Internal Energy', color='purple')
    axes[1, 1].set_ylabel('Internal Energy')
    axes[1, 1].set_title('Internal Energy')
    axes[1, 1].set_xlabel('Position')
    axes[1, 1].grid()
    axes[1, 1].legend()

    # Add initial values text at the top of the figure
    if initial_values:
        ρL, uL, pL, ρR, uR, pR = initial_values
        fig.text(0.5, 0.08, 
                 f"Initial Values:  ρL={ρL}, uL={uL}, pL={pL},  ρR={ρR}, uR={uR}, pR={pR}",
                 ha='center', va='center', fontsize=10)

    # Add computed pressure values below the plot
    if computed_values:
        p_star, p_TR, p_PV, p_TS, p_avg = computed_values
        fig.text(0.5, 0.05, 
                 f"Computed Values:  p*={p_star:.4f}, p_TR={p_TR:.4f}, p_PV={p_PV:.4f}, p_TS={p_TS:.4f}, 0.5*(pL+pR)={p_avg:.4f}",
                 ha='center', va='center', fontsize=10)

    # Add star region values below the computed values
    if star_values:
        p_star, u_star, ρ_star_L, ρ_star_R = star_values
        fig.text(0.5, 0.02, 
                 f"Exact Solutions:  p*={p_star:.4f}, u*={u_star:.4f}, ρ_L*={ρ_star_L:.4f}, ρ_R*={ρ_star_R:.4f}",
                 ha='center', va='center', fontsize=10)

    # Adjust layout for better spacing
    plt.tight_layout(rect=[0.02, 0.1, 0.98, 1])  # Leave space for text annotations rect = [left, bottom, right, top]

    # Save and/or show the plot
    if save:
        plt.savefig(save_path, dpi=300)
        print(f"Plot saved to '{save_path}'")
    plt.show()

def animate_Riemann_problem(domlen, timeout, cells, timesteps, 
                            save=False, filename="Riemann_animation.gif",
                            initial_values=None, computed_values=None, star_values=None):
    """
    Animate the evolution of the Riemann problem over time and save as a GIF.

    Parameters:
        domlen (float): Domain length.
        timeout (float): Final output time.
        cells (int): Number of spatial cells.
        timesteps (int): Number of time steps for the animation.
        save (bool): If True, saves the animation as a GIF.
        filename (str): Name of the output GIF file.
        initial_values (tuple): Initial states (ρL, uL, pL, ρR, uR, pR).
        computed_values (tuple): Computed pressures (p*, p_TR, p_PV, p_TS, 0.5*(pL+pR)).
        star_values (tuple): Exact solutions (p*, u*, ρ*_L, ρ*_R).
    """
    # Validate inputs
    if timeout <= 0:
        raise ValueError("Timeout must be a positive non-zero value.")
    if timesteps <= 0:
        raise ValueError("Number of timesteps must be a positive integer.")
    
    # Ensure filename has the correct extension
    if not filename.endswith(".gif"):
        print("Warning: Changing file extension to '.gif' for PillowWriter.")
        filename = os.path.splitext(filename)[0] + ".gif"

    def solve_frame(domlen, current_time, cells):
        """Solve the Riemann problem for a single frame (time step)."""
        if current_time <= 0:
            current_time = 1e-6  # Small non-zero time to avoid division errors

        # Solve the Sod problem (update solver call as needed)
        _, density, velocity, pressure, internal_energy = solve_Riemann_problem(domlen, current_time, cells)
        return density, velocity, pressure, internal_energy

    # Precompute min and max values for each quantity
    positions = np.linspace(0, domlen, cells)
    ranges = {'density': [float('inf'), float('-inf')],
              'velocity': [float('inf'), float('-inf')],
              'pressure': [float('inf'), float('-inf')],
              'internal_energy': [float('inf'), float('-inf')]}

    for frame in range(timesteps):
        current_time = frame * (timeout / timesteps)
        density, velocity, pressure, internal_energy = solve_frame(domlen, current_time, cells)

        # Update global min/max values
        ranges['density'] = [min(ranges['density'][0], np.min(density)), max(ranges['density'][1], np.max(density))]
        ranges['velocity'] = [min(ranges['velocity'][0], np.min(velocity)), max(ranges['velocity'][1], np.max(velocity))]
        ranges['pressure'] = [min(ranges['pressure'][0], np.min(pressure)), max(ranges['pressure'][1], np.max(pressure))]
        ranges['internal_energy'] = [min(ranges['internal_energy'][0], np.min(internal_energy)), 
                                     max(ranges['internal_energy'][1], np.max(internal_energy))]

    # Initialize the figure
    fig, axes = plt.subplots(2, 2, figsize=(10, 8))
    fig.subplots_adjust(bottom=0.2, top=0.9, hspace=0.3)  # Adjust margins and spacing
    axes = axes.flatten()

    # Titles, Colors, and Line Styles
    properties = [
        ("Density", "blue", "solid"),
        ("Velocity", "green", "dashed"),
        ("Pressure", "red", "dashdot"),
        ("Internal Energy", "purple", "dotted")
    ]

    # Initialize empty lines for animation
    lines = []
    for i, (ax, (title, color, linestyle), (y_min, y_max)) in enumerate(zip(axes, properties, ranges.values())):
        line, = ax.plot([], [], lw=2, color=color, linestyle=linestyle)
        lines.append(line)
        ax.set_xlim(0, domlen)
        ax.set_ylim(y_min - 0.1 * abs(y_min), y_max + 0.1 * abs(y_max))  # Add dynamic padding
        ax.set_title(title, fontsize=12, fontweight='bold')
        ax.set_ylabel(title)
        ax.grid(True)

        # Only add x-axis labels for the bottom two plots
        if i < 2:  # Top row
            ax.set_xticklabels([])
        else:  # Bottom row
            ax.set_xlabel("Position")

    # Add annotations for initial values, computed values, and star region values
    if initial_values:
        ρL, uL, pL, ρR, uR, pR = initial_values
        fig.text(0.5, 0.12, 
                 f"Initial Values:  ρL={ρL}, uL={uL}, pL={pL},  ρR={ρR}, uR={uR}, pR={pR}",
                 ha='center', va='center', fontsize=10)

    if computed_values:
        p_star, p_TR, p_PV, p_TS, p_avg = computed_values
        fig.text(0.5, 0.08, 
                 f"Computed Values:  p*={p_star:.4f}, p_TR={p_TR:.4f}, p_PV={p_PV:.4f}, p_TS={p_TS:.4f}, 0.5*(pL+pR)={p_avg:.4f}",
                 ha='center', va='center', fontsize=10)

    if star_values:
        p_star, u_star, ρ_star_L, ρ_star_R = star_values
        fig.text(0.5, 0.04, 
                 f"Exact Solutions:  p*={p_star:.4f}, u*={u_star:.4f}, ρ_L*={ρ_star_L:.4f}, ρ_R*={ρ_star_R:.4f}",
                 ha='center', va='center', fontsize=10)

    # Function to update the plots at each time step
    def update(frame):
        current_time = frame * (timeout / timesteps)
        if current_time == 0: 
            current_time = 1e-6  # Small non-zero time to avoid division errors

        density, velocity, pressure, internal_energy = solve_frame(domlen, current_time, cells)
        
        # Update each line with the current data
        lines[0].set_data(positions, density)
        lines[1].set_data(positions, velocity)
        lines[2].set_data(positions, pressure)
        lines[3].set_data(positions, internal_energy)
        
        fig.suptitle(f"Riemann Problem at Time t = {current_time:.4f}", fontsize=14, fontweight='bold')
        return lines

    # Create the animation
    anim = FuncAnimation(fig, update, frames=timesteps, blit=True, repeat=False)

    # Save or show the animation
    if save:
        results_folder = os.path.join(os.getcwd(), "Results")
        if not os.path.exists(results_folder):
            os.makedirs(results_folder)
        save_path = os.path.join(results_folder, filename)

        # Save as GIF using Pillow
        anim.save(save_path, writer=PillowWriter(fps=8))
        print(f"Animation saved to '{save_path}'")
    else:
        plt.show()

#--------------------------------------------------------------#
#                 Exicution (Defining specific problem)
#--------------------------------------------------------------#

def main():
    # Riemann problem parameters
    gammas.GAMMA = 1.4
    compute_gamma_constants()
    
    
    #--------------------------------------------------------------#
    #                  START: User Defined Parameters                         
    #--------------------------------------------------------------#
    #                       Manual user input (comment/uncomment)
    #--------------------------------------------------------------#
    # states.DL, states.UL, states.PL = 1, -2, 0.4  # Left state
    # states.DR, states.UR, states.PR = 1, 2, 0.4 # Right state
    
    # domlen = 1.0      # Domain length
    # timeout = 0.15    # Output time
    # timesteps = 50      # Number of time steps (frames) in the animation
    # cells = 200       # Number of cells
    #--------------------------------------------------------------#
    #                       From file (comment/uncomment)
    #--------------------------------------------------------------#
    # Input file containing parameters
    input_file = 'Test1_input.txt'  # Specify the input file name

    # Read parameters from input file
    domlen, diaph, cells, timeout, mpa = read_input(input_file)
    timesteps = 50      # Number of time steps (frames) in the animation
    #--------------------------------------------------------------#
    
    filename_png = 'Test1.png' # Name of image
    filename_gif = 'Test1.gif' # Name of gif
    #--------------------------------------------------------------#
    #                   END: User Defined Parameters                 
    #--------------------------------------------------------------#

    #--------------------------------------------------------------#
    #                          Calculation
    #--------------------------------------------------------------#

    positions, density, velocity, pressure, internal_energy = solve_Riemann_problem(domlen, timeout, cells)

    # Solve for p*, u*, rho*_L, and rho*_R
    p_star, u_star, rho_star_L, rho_star_R = STARPU(GUESSP())
    

    # Compute Two-Rarefaction Pressure (p_TR)
    pq = (states.PL / states.PR) ** gammas.G1
    u_TR = ((pq * states.UL / states.CL) + (states.UR / states.CR) + gammas.G4 * (pq - 1.0)) / (
        pq / states.CL + 1.0 / states.CR
    )
    p_TR = 0.5 * (states.PL * (1.0 + gammas.G7 * (states.UL - u_TR) / states.CL) ** gammas.G3 +
                  states.PR * (1.0 + gammas.G7 * (u_TR - states.UR) / states.CR) ** gammas.G3)

    # Compute PVRS and average pressure
    p_PV = 0.5 * (states.PL + states.PR) + 0.5 * (states.UL - states.UR) * 0.25 * (states.DL + states.DR) * (states.CL + states.CR)
    p_avg = 0.5 * (states.PL + states.PR)

    # Compute Two-Shock Pressure (p_TS) - ver 1
    G_EL = math.sqrt((gammas.G5 / states.DL) / (gammas.G6 * states.PL + p_PV))
    G_ER = math.sqrt((gammas.G5 / states.DR) / (gammas.G6 * states.PR + p_PV))
    p_TS = (G_EL * states.PL + G_ER * states.PR - (states.UR - states.UL)) / (G_EL + G_ER)
    
    # Compute Two-Shock Pressure (p_TS) - ver 2 use for Test 2!!

    # # Small epsilon to prevent division by zero
    # EPSILON = 1e-12

    # # Initial calculation with p_PV
    # try:
    #     G_EL = math.sqrt(max(0.0, (gammas.G5 / states.DL) / (gammas.G6 * states.PL + p_PV)))
    #     G_ER = math.sqrt(max(0.0, (gammas.G5 / states.DR) / (gammas.G6 * states.PR + p_PV)))
    # except ValueError as e:
    #     print("Error: Negative value encountered during square root calculation.")
    #     raise e

    # # Compute the denominator and check for near-zero values
    # denominator = G_EL + G_ER
    # if abs(denominator) < EPSILON:
    #     print("Warning: G_EL + G_ER is nearly zero. Adjusting denominator to prevent division by zero.")
    #     denominator = EPSILON  # Adjust to small positive value

    # # Compute p_TS using adjusted denominator
    # G_EL = math.sqrt((gammas.G5 / states.DL) / (gammas.G6 * states.PL + p_avg))
    # G_ER = math.sqrt((gammas.G5 / states.DR) / (gammas.G6 * states.PR + p_avg))
    # p_TS = (G_EL * states.PL + G_ER * states.PR - (states.UR - states.UL)) / (G_EL + G_ER)


    # Pass initial and computed values to the plot function
    initial_values = (states.DL, states.UL, states.PL, states.DR, states.UR, states.PR)
    computed_values = (p_star, p_TR, p_PV, p_TS, p_avg)
    # Pass star region values to the plot function
    star_values = (p_star, u_star, rho_star_L, rho_star_R)

    #--------------------------------------------------------------#
    #                        Post-process
    #--------------------------------------------------------------#
    plot_Riemann_problem(positions, density, velocity, pressure, internal_energy,
                     save=True, filename=filename_png, initial_values=initial_values,
                     computed_values=computed_values, star_values=star_values)  
    
    
    animate_Riemann_problem(domlen, timeout, cells, timesteps, save=True, filename=filename_gif, initial_values=initial_values,
                     computed_values=computed_values, star_values=star_values)


if __name__ == "__main__":
    main()