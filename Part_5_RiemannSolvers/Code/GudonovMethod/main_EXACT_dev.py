""" 
Exact Riemann Solver for the Time-Dependent 
    One-Dimensional Euler Equations 

Purpose: To solve the Riemann problem exactly
         for the time-dependent one-dimensional 
         Euler equations for an ideal gas.

Theory is found in Ref. 1, Chapter 4 and in original 
references therein.

Reference:
1. Toro, E. F., "Riemann Solvers and Numerical 
                Methods for Fluid Dynamics" 
                Springer-Verlag, 1997
                Second Edition, 1999

This program logic is part of:

NUMERICA
A Library of Source Codes for Teaching, 
Research and Applications, 
by E. F. Toro
Published by NUMERITEK LTD, 1999
Website: www.numeritek.com
 """

import math
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter
import numpy as np
import os

#--------------------------------------------------------------#
#             Initalization and variable precomputing
#--------------------------------------------------------------#

class Gammas:
    def __init__(self):
        self.GAMMA = None
        self.G1 = None
        self.G2 = None
        self.G3 = None
        self.G4 = None
        self.G5 = None
        self.G6 = None
        self.G7 = None
        self.G8 = None

class States:
    def __init__(self):
        self.DL = None  # Density (left state)
        self.UL = None  # Velocity (left state)
        self.PL = None  # Pressure (left state)
        self.CL = None  # Sound speed (left state)
        self.DR = None  # Density (right state)
        self.UR = None  # Velocity (right state)
        self.PR = None  # Pressure (right state)
        self.CR = None  # Sound speed (right state)

# Initialize global variables
gammas = Gammas()
states = States()

def read_input(file_name):
    """
    Reads input data from the input file 'TestX_input.txt' and handles comments.
    """
    def clean_line(line):
        # Split the line at '!' or '#' and strip extra spaces
        return line.split('!')[0].split('#')[0].strip()

    with open(file_name, 'r') as file:
        lines = file.readlines()
        
        # Clean each line to remove comments and extra spaces
        clean_lines = [clean_line(line) for line in lines if clean_line(line)]

        # Parse the cleaned lines
        domlen = float(clean_lines[0])   # Domain length
        diaph = float(clean_lines[1])    # Initial discontinuity position
        cells = int(clean_lines[2])      # Number of computing cells
        gammas.GAMMA = float(clean_lines[3])  # Ratio of specific heats
        timeout = float(clean_lines[4])  # Output time
        states.DL = float(clean_lines[5])  # Density left
        states.UL = float(clean_lines[6])  # Velocity left
        states.PL = float(clean_lines[7])  # Pressure left
        states.DR = float(clean_lines[8])  # Density right
        states.UR = float(clean_lines[9])  # Velocity right
        states.PR = float(clean_lines[10]) # Pressure right
        mpa = float(clean_lines[11])  # Normalizing constant

    return domlen, diaph, cells, timeout, mpa

def compute_gamma_constants():
    """Computes gamma-related constants."""
    GAMMA = gammas.GAMMA
    gammas.G1 = (GAMMA - 1.0) / (2.0 * GAMMA)
    gammas.G2 = (GAMMA + 1.0) / (2.0 * GAMMA)
    gammas.G3 = 2.0 * GAMMA / (GAMMA - 1.0)
    gammas.G4 = 2.0 / (GAMMA - 1.0)
    gammas.G5 = 2.0 / (GAMMA + 1.0)
    gammas.G6 = (GAMMA - 1.0) / (GAMMA + 1.0)
    gammas.G7 = (GAMMA - 1.0) / 2.0
    gammas.G8 = GAMMA - 1.0

def compute_sound_speeds():
    """Computes sound speeds for left and right states."""
    states.CL = math.sqrt(gammas.GAMMA * states.PL / states.DL)
    states.CR = math.sqrt(gammas.GAMMA * states.PR / states.DR)

def check_vacuum_condition():
    """Checks the pressure positivity condition."""
    if gammas.G4 * (states.CL + states.CR) <= (states.UR - states.UL):
        print("\n*** Vacuum is generated by data ***")
        print("*** Program stopped ***\n")
        exit(1)

#--------------------------------------------------------------#
#                          Core functions
#--------------------------------------------------------------#

def GUESSP():
    """
     Purpose: to provide a guessed value for pressure
              PM in the Star Region. The choice is made
              according to adaptive Riemann solver using
              the PVRS, TRRS and TSRS approximate
              Riemann solvers. See Sect. 9.5 of Chapt. 9
              of Ref. 1
    """
    QUSER = 2.0  # Threshold for solver selection

    # Compute guess pressure using PVRS (Pressure-Velocity Riemann Solver)
    CUP = 0.25 * (states.DL + states.DR) * (states.CL + states.CR)
    PPV = 0.5 * (states.PL + states.PR) + 0.5 * (states.UL - states.UR) * CUP
    PPV = max(0.0, PPV)  # Ensure pressure is non-negative
    PMIN = min(states.PL, states.PR)
    PMAX = max(states.PL, states.PR)
    QMAX = PMAX / PMIN

    # Select solver
    if QMAX <= QUSER and (PMIN <= PPV <= PMAX):
        # PVRS solver
        PM = PPV
    elif PPV < PMIN:
        # Two-Rarefaction Riemann solver (TRRS)
        PQ = (states.PL / states.PR) ** gammas.G1
        UM = (PQ * states.UL / states.CL + states.UR / states.CR + 
              gammas.G4 * (PQ - 1.0)) / (PQ / states.CL + 1.0 / states.CR)
        PTL = 1.0 + gammas.G7 * (states.UL - UM) / states.CL
        PTR = 1.0 + gammas.G7 * (UM - states.UR) / states.CR
        PM = 0.5 * (states.PL * PTL ** gammas.G3 + states.PR * PTR ** gammas.G3)
    else:
        # Two-Shock Riemann solver (TSRS) with PVRS estimate
        GEL = math.sqrt((gammas.G5 / states.DL) / (gammas.G6 * states.PL + PPV))
        GER = math.sqrt((gammas.G5 / states.DR) / (gammas.G6 * states.PR + PPV))
        PM = (GEL * states.PL + GER * states.PR - (states.UR - states.UL)) / (GEL + GER)
    
    return PM

def PREFUN(P, DK, PK, CK):
    """
    Evaluates the pressure function (F) and its derivative (FD) in exact Riemann solver.
    Inputs:
        P  - Pressure
        DK - Density
        PK - Initial Pressure
        CK - Sound speed
    Outputs:
        F  - Pressure function
        FD - Derivative of the pressure function
    """
    if P <= PK:
        # Rarefaction wave
        PRAT = P / PK
        F = gammas.G4 * CK * (PRAT ** gammas.G1 - 1.0)
        FD = (1.0 / (DK * CK)) * PRAT ** (-gammas.G2)
    else:
        # Shock wave
        AK = gammas.G5 / DK
        BK = gammas.G6 * PK
        QRT = math.sqrt(AK / (BK + P))
        F = (P - PK) * QRT
        FD = (1.0 - 0.5 * (P - PK) / (BK + P)) * QRT
    
    return F, FD


def STARPU(PSTART):
    """
    Computes the pressure p*, velocity u*, and densities in the star region using Newton-Raphson iteration.
    Returns: p*, u*, rho*_L, rho*_R.
    """
    TOLPRE = 1.0e-6  # Convergence tolerance
    NRITER = 20      # Max iterations

    # Initial guess
    POLD = PSTART
    UDIFF = states.UR - states.UL

    for _ in range(NRITER):
        # Compute pressure functions for left and right
        FL, FLD = PREFUN(POLD, states.DL, states.PL, states.CL)
        FR, FRD = PREFUN(POLD, states.DR, states.PR, states.CR)

        # Newton-Raphson iteration
        PNEW = POLD - (FL + FR + UDIFF) / (FLD + FRD)
        CHANGE = 2.0 * abs((PNEW - POLD) / (PNEW + POLD))

        if CHANGE <= TOLPRE:
            break
        POLD = max(PNEW, TOLPRE)  # Ensure positive pressure

    else:
        raise ValueError("Newton-Raphson failed to converge for p*")

    # Final p*
    p_star = PNEW

    # Compute velocity u* in the star region
    FL, _ = PREFUN(p_star, states.DL, states.PL, states.CL)
    FR, _ = PREFUN(p_star, states.DR, states.PR, states.CR)
    u_star = 0.5 * (states.UL + states.UR + FR - FL)

    # Compute star region densities
    if p_star <= states.PL:
        # Left rarefaction
        rho_star_L = states.DL * (p_star / states.PL) ** (1.0 / gammas.GAMMA)
    else:
        # Left shock
        rho_star_L = states.DL * (p_star / states.PL + gammas.G6) / (p_star / states.PL * gammas.G6 + 1.0)

    if p_star <= states.PR:
        # Right rarefaction
        rho_star_R = states.DR * (p_star / states.PR) ** (1.0 / gammas.GAMMA)
    else:
        # Right shock
        rho_star_R = states.DR * (p_star / states.PR + gammas.G6) / (p_star / states.PR * gammas.G6 + 1.0)

    return p_star, u_star, rho_star_L, rho_star_R


def SAMPLE(PM, UM, S):
    """
    Samples the solution throughout the wave pattern.
    Input:
        PM - Pressure in star region
        UM - Velocity in star region
        S  - Speed X/T
    Output:
        D  - Density at the sampled point
        U  - Velocity at the sampled point
        P  - Pressure at the sampled point
    """
    # Local variables
    D, U, P = 0.0, 0.0, 0.0

    # Left of the contact discontinuity
    if S <= UM:
        if PM <= states.PL:
            # Left rarefaction
            SHL = states.UL - states.CL
            if S <= SHL:
                # Left data state
                D, U, P = states.DL, states.UL, states.PL
            else:
                CML = states.CL * (PM / states.PL) ** gammas.G1
                STL = UM - CML
                if S > STL:
                    # Star Left state
                    D = states.DL * (PM / states.PL) ** (1.0 / gammas.GAMMA)
                    U = UM
                    P = PM
                else:
                    # Inside left fan
                    U = gammas.G5 * (states.CL + gammas.G7 * states.UL + S)
                    C = gammas.G5 * (states.CL + gammas.G7 * (states.UL - S))
                    D = states.DL * (C / states.CL) ** gammas.G4
                    P = states.PL * (C / states.CL) ** gammas.G3
        else:
            # Left shock
            PML = PM / states.PL
            SL = states.UL - states.CL * math.sqrt(gammas.G2 * PML + gammas.G1)
            if S <= SL:
                # Left data state
                D, U, P = states.DL, states.UL, states.PL
            else:
                # Star Left state
                D = states.DL * (PML + gammas.G6) / (PML * gammas.G6 + 1.0)
                U = UM
                P = PM
    else:
        # Right of the contact discontinuity
        if PM > states.PR:
            # Right shock
            PMR = PM / states.PR
            SR = states.UR + states.CR * math.sqrt(gammas.G2 * PMR + gammas.G1)
            if S >= SR:
                # Right data state
                D, U, P = states.DR, states.UR, states.PR
            else:
                # Star Right state
                D = states.DR * (PMR + gammas.G6) / (PMR * gammas.G6 + 1.0)
                U = UM
                P = PM
        else:
            # Right rarefaction
            SHR = states.UR + states.CR
            if S >= SHR:
                # Right data state
                D, U, P = states.DR, states.UR, states.PR
            else:
                CMR = states.CR * (PM / states.PR) ** gammas.G1
                STR = UM + CMR
                if S <= STR:
                    # Star Right state
                    D = states.DR * (PM / states.PR) ** (1.0 / gammas.GAMMA)
                    U = UM
                    P = PM
                else:
                    # Inside right fan
                    U = gammas.G5 * (-states.CR + gammas.G7 * states.UR + S)
                    C = gammas.G5 * (states.CR - gammas.G7 * (states.UR - S))
                    D = states.DR * (C / states.CR) ** gammas.G4
                    P = states.PR * (C / states.CR) ** gammas.G3
    
    return D, U, P

#--------------------------------------------------------------#
#                          Calculation
#--------------------------------------------------------------#

def solve_Riemann_problem(domlen, timeout, cells):
    """Solve the Riemann problem."""
    # Compute sound speeds
    compute_sound_speeds()
    
    # Solve for PM and UM
    PM = GUESSP()

    # Solve for star region values
    PM, UM, rho_star_L, rho_star_R = STARPU(PM)

    # Discretize the spatial domain
    dx = domlen / cells
    positions = [(i + 0.5) * dx for i in range(cells)]
    
    # Sample the solution
    density = []
    velocity = []
    pressure = []
    internal_energy = []
    
    for xpos in positions:
        s = (xpos - domlen / 2.0) / timeout
        D, U, P = SAMPLE(PM, UM, s)
        density.append(D)
        velocity.append(U)
        pressure.append(P)
        e = P / ((gammas.GAMMA - 1.0) * D)  # Compute internal energy
        internal_energy.append(e)
    
    return positions, density, velocity, pressure, internal_energy



#--------------------------------------------------------------#
#                 Exicution (Defining specific problem)
#--------------------------------------------------------------#

def main(dl, ul, pl, dr, ur, pr, gamma):
    """
    Solve the exact Riemann problem for given left and right states.
    Inputs:
        dl, ul, pl - Left density, velocity, pressure
        dr, ur, pr - Right density, velocity, pressure
        gamma      - Ratio of specific heats
    Returns:
        rho_star, u_star, p_star - Exact solution at the interface (x/t = 0)
    """
    gammas.GAMMA = gamma
    compute_gamma_constants()

    # Set initial states
    states.DL, states.UL, states.PL = dl, ul, pl
    states.DR, states.UR, states.PR = dr, ur, pr

    # Compute speed of sound for left and right states
    states.CL = (gamma * pl / dl) ** 0.5  # Left speed of sound
    states.CR = (gamma * pr / dr) ** 0.5  # Right speed of sound

    # Solve for star region
    PM = GUESSP()  # Pressure in the star region
    p_star, u_star, rho_star_L, rho_star_R = STARPU(PM)

    # Sample the solution at the interface (x/t = 0) to get final values
    xpos = 0.0  # Interface at x/t = 0
    s = xpos  # Since x/t = 0 corresponds to s = 0

    D, U, P = SAMPLE(PM, u_star, s)  # Use the SAMPLE function to determine values at x/t = 0

    return D, U, P  # Density, velocity, and pressure at the interface



